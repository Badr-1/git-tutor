#!/bin/bash

# Color definitions
readonly RED='\033[1;31m'
readonly GREEN='\033[1;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[1;34m'
readonly PURPLE='\033[1;35m'
readonly CYAN='\033[1;36m'
readonly GRAY='\033[1;90m'
readonly NC='\033[0m' # No Color

print_section_header() {
    local title=$1
    echo -en "${PURPLE}$title${NC}\n"
}

handle_error() {
    local exit_code=$1
    local error_message=$2
    if [ $exit_code -ne 0 ]; then
        echo -ne "${RED}Error: $error_message${NC}\n" >&2
        exit $exit_code
    fi
}

commit() {
    local amend=$1
    if [[ $amend = '--amend' ]]; then
        local message="$(git log -1 --pretty=%B 2>/dev/null)'"
        git commit --allow-empty --amend -m "$message" >/dev/null 2>&1
        handle_error $? "Failed to amend commit"
    else
        local message="C$commits_cnt"
        git commit --allow-empty -m "$message" >/dev/null 2>&1
        handle_error $? "Failed to create commit"
        commits_cnt=$((commits_cnt + 1))
    fi
    git tag "$message" >/dev/null 2>&1
    handle_error $? "Failed to create tag"
}

log() {
    local all="$(echo "$1" | grep -c -- '--all')"
    echo -en "${CYAN}"
    if [ $all -ne 0 ]; then
        git log --all --graph --decorate=short --pretty=format:"%d %s" 2>/dev/null |
            sed -E "s/tag: [^,)]*,? ?//g" |
            sed -E "s/, \)/)/g" |
            sed -E "s/\(\)//g" |
            awk -v yellow="$YELLOW" -v green="$GREEN" -v blue="$BLUE" -v nc="$NC" '
    {
        gsub(/\*/, yellow "&" nc);
        gsub(/\(.*\)/, green "&" nc);
        sub(/\) /, blue);
        print blue $0 nc;
    }'
    else
        git log --graph --decorate=short --pretty=format:"%d %s" 2>/dev/null |
            sed -E "s/tag: [^,)]*,? ?//g" |
            sed -E "s/, \)/)/g" |
            sed -E "s/\(\)//g" |
            awk -v yellow="$YELLOW" -v green="$GREEN" -v blue="$BLUE" -v nc="$NC" '
    {
        gsub(/\*/, yellow "&" nc);
        gsub(/\(.*\)/, green "&" nc);
        sub(/\) /, blue);
        print blue $0 nc;
    }'

    fi
}

checkout() {
    local target=$1
    if [ "$target" = '-b' ]; then
        target=$2
        git checkout -b "$target" >/dev/null 2>&1
        handle_error $? "Failed to create and checkout branch: $target"
    else
        git checkout "$target" >/dev/null 2>&1
        handle_error $? "Failed to checkout: $target"
    fi
}

branch() {
    git branch "$@" >/dev/null 2>&1
    handle_error $? "Failed to create branch: $@"
}

switch() {
    local target=$1
    if [ "$target" = '-c' ]; then
        target=$2
        git switch -c "$target" >/dev/null 2>&1
        handle_error $? "Failed to create and switch to branch: $target"
    else
        git switch "$target" >/dev/null 2>&1
        handle_error $? "Failed to switch to: $target"
    fi
}

revert() {
    local target=$1
    local message="$target'"
    while ! git tag "$message" 2>/dev/null; do
        message="$message'"
    done
    git tag -d "$message" >/dev/null 2>&1
    git commit --allow-empty -m "$message" >/dev/null 2>&1
    handle_error $? "Failed to revert commit: $target"
    git tag "$message" >/dev/null 2>&1
}

reset() {
    local target=$1
    git reset --hard "$target" >/dev/null 2>&1
    handle_error $? "Failed to reset to: $target"
}

merge() {
    local target=$1
    local message="C$commits_cnt"
    git merge --ff-only "$target" -m "$message" >/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        git merge "$target" -m "$message" >/dev/null 2>&1
        handle_error $? "Failed to merge to: $target" >/dev/null 2>&1
        commits_cnt=$((commits_cnt + 1))
        git tag "$message" >/dev/null 2>&1
        handle_error $? "Failed to create tag $message"
    fi
}

cherry_pick() {
    local commit=$1
    local message="$commit'"
    while ! git tag "$message" 2>/dev/null; do
        message="$message'"
    done
    git tag -d "$message" >/dev/null 2>&1
    git cherry-pick -n --allow-empty --keep-redundant-commits $commit && git commit --allow-empty -m "$message" >/dev/null 2>&1
    git tag "$message" >/dev/null 2>&1
    handle_error $? "Failed to create tag for cherry-pick: $message"
    commits_cnt=$((commits_cnt + 1))
}

rebase() {
    local target=$1
    local current_branch="$(git rev-parse --abbrev-ref HEAD)"
    local commits=($(git log --format=%H "$target..$current_branch" | tac))
    git reset --hard "$target" >/dev/null 2>&1

    for commit in "${commits[@]}"; do
        local message="$(git log -1 --format=%B "$commit" 2>/dev/null)"
        while ! git tag "$message" 2>/dev/null; do
            message="$message'"
        done
        git tag -d "$message" >/dev/null 2>&1
        git commit --allow-empty -m "$message" >/dev/null 2>&1
        handle_error $? "Failed to revert commit: $target"
        git tag "$message" >/dev/null 2>&1
        handle_error $? "Failed to create tag for rebased commit: $message"
    done
}

init() {
    commits_cnt=0
    commands_cnt=0
}

cmd_exe_sandbox() {
    init
    exec 3<&0
    rm -rf sandbox >/dev/null 2>&1
    git init sandbox >/dev/null 2>&1
    cd sandbox >/dev/null 2>&1
    show_help
    echo -en "${YELLOW}> "
    echo -en "${BLUE} "
    while IFS= read -r command <&3; do
        IFS=' ' read -r -a tokens <<<"$command"
        if [[ ${tokens[0]} == 'git' ]]; then
            local cmd=${tokens[1]}
            local args=${tokens[@]:2}
            case $cmd in
            commit)
                commit $args
                ;;
            checkout)
                checkout $args
                ;;
            cherry-pick)
                cherry_pick $args
                ;;
            switch)
                switch $args
                ;;
            merge)
                merge $args
                ;;
            rebase)
                rebase $args
                ;;
            branch)
                branch $args
                ;;
            log)
                log $args
                ;;
            revert)
                revert $args
                ;;
            reset)
                reset $args
                ;;
            *)
                echo -ne "${RED}Unknown '$command' command.\nType 'help' for available commands${NC}\n"
                ;;
            esac
        else
            case ${tokens[0]} in
            clear)
                clear
                ;;
            reset)
                clear
                cd .. >/dev/null 2>&1
                rm -rf sandbox
                init
                git init sandbox >/dev/null 2>&1
                cd sandbox >/dev/null 2>&1
                ;;
            help)
                show_help
                ;;
            exit)
                break
                ;;
            *)
                echo -ne "${RED}Unknown '$command' command.\nType 'help' for available commands${NC}\n"
                ;;
            esac
        fi
        echo -en "${YELLOW}> "
        echo -en "${BLUE} "
    done
    cd .. >/dev/null 2>&1
    rm -rf sandbox
    exec 3<&-
}

cmd_exe_load() {
    init
    local dir_name=$1
    shift
    local source=("$@")
    print_section_header "Loading $dir_name"
    rm -rf "$dir_name" >/dev/null 2>&1
    git init "$dir_name" >/dev/null 2>&1
    cd "$dir_name" >/dev/null 2>&1
    for cmd in "${source[@]}"; do
        read -ra tokens <<<"$cmd"
        local cmd=${tokens[1]}
        local args=${tokens[@]:2}
        case $cmd in
        commit)
            commit $args
            ;;
        checkout)
            checkout $args
            ;;
        cherry-pick)
            cherry_pick $args
            ;;
        switch)
            switch $args
            ;;
        merge)
            merge $args
            ;;
        rebase)
            rebase $args
            ;;
        branch)
            branch $args
            ;;
        log)
            log $args
            ;;
        revert)
            revert $args
            ;;
        reset)
            reset $args
            ;;
        esac
    done
}

game_prompt() {
    if (($commands_cnt < $level_commands_cnt)); then
        echo -en "${GREEN}($commands_cnt/$level_commands_cnt)${NC}"
    else
        echo -en "${RED}($commands_cnt/$level_commands_cnt)${NC}"
    fi
    echo -en "${YELLOW}> "
    echo -en "${BLUE} "
}

compare_repos() {
    echo -ne "${NC}"
    local play_dir="../play"
    local goal_dir="../goal"

    [[ ! -d "$play_dir" ]] && echo "Play directory not found" && return 1
    [[ ! -d "$goal_dir" ]] && echo "Goal directory not found" && return 1

    local play_out="$(cd "$play_dir" && log --all)"
    local goal_out="$(cd "$goal_dir" && log --all)"

    if [[ "$play_out" == "$goal_out" ]]; then
        pass=true
    else
        pass=false
    fi
}

cleanup() {
    cd .. >/dev/null 2>&1
    rm -rf goal play
}

cmd_exe_play() {
    local level_name=$1
    exec 3<&0
    game_prompt
    while IFS= read -r command <&3; do
        IFS=' ' read -r -a tokens <<<"$command"
        if [[ ${tokens[0]} == 'git' ]]; then
            local cmd=${tokens[1]}
            local args=${tokens[@]:2}
            case $cmd in
            commit)
                commit $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            checkout)
                checkout $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            cherry-pick)
                cherry_pick $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            switch)
                switch $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            merge)
                merge $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            branch)
                branch $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            rebase)
                rebase $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            log)
                log $args
                game_prompt
                continue
                ;;
            revert)
                revert $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            reset)
                reset $args
                commands_cnt=$((commands_cnt + 1))
                ;;
            *)
                echo -ne "${RED}Unknown '$command' command.\nType 'help' for available commands${NC}\n"
                game_prompt
                continue
                ;;
            esac
        else
            case ${tokens[0]} in
            description)
                echo -ne "${YELLOW}$level_description${NC}"
                ;;
            hint)
                echo -ne "${YELLOW}$level_hint${NC}"
                ;;
            clear)
                clear
                cd ..
                rm -rf goal
                old_commits_cnt=$commits_cnt
                old_commands_cnt=$commands_cnt
                cmd_exe_load 'goal' "${goal[@]}"
                log --all
                cd ..
                print_section_header "Loading play"
                commits_cnt=$old_commits_cnt
                commands_cnt=$old_commands_cnt
                cd play
                log --all
                game_prompt
                continue
                ;;
            reset)
                clear
                cd ..
                rm -rf goal play
                init
                level_setup $level_name
                game_prompt
                continue
                ;;
            help)
                show_help
                game_prompt
                continue
                ;;
            exit)
                break
                ;;
            *)
                echo -ne "${RED}Unknown '$command' command.\nType 'help' for available commands${NC}\n"
                game_prompt
                continue
                ;;
            esac
        fi
        play+=("$command")
        compare_repos
        if [[ $pass == true ]]; then
            echo -ne "${GREEN}🎉 Congratulations!${NC}\n"
            cleanup
            if (($commands_cnt <= $level_commands_cnt)); then
                echo -e "${GREEN}The max commands required was '$level_commands_cnt' and yours was '$commands_cnt'${NC}"
            else
                echo -e "${RED}The max commands required was '$level_commands_cnt' and yours was '$commands_cnt'${NC}"
                echo -e "${RED}Try again, but better!${NC}"
                echo -ne "${YELLOW}$level_hint${NC}"
            fi
            exit 0
        fi
        game_prompt
    done
    cleanup
}

level_1_setup() {
    level_description="$(
        cat <<EOF
description:${NC}
This level is about creating branches and committing to them
it's a place to practice using:
- git commit
- git branch
- git checkout\n
EOF
    )"
    level_hint="$(
        cat <<EOF
HINT: ${NC}only if there were a command that create and checkout to branch at once!\n
EOF
    )"
    goal=("git commit" "git checkout -b new" "git commit")
    base=("git commit")

}

level_setup() {
    local level_name=$1
    case $level_name in
    level_1)
        level_1_setup
        ;;
    *)
        echo "Unknown level: $level_name"
        exit 1
        ;;
    esac
    level_commands_cnt=$((${#goal[@]} - ${#base[@]}))
    cmd_exe_load 'goal' "${goal[@]}"
    log --all
    cd ..
    cmd_exe_load 'play' "${base[@]}"
    log --all
    play=("${base[@]}")
}

show_help() {

    echo -e "
${GREEN}Usage:${NC}
  ${YELLOW}git-tutor play <level_name>${NC}     Start playing a specific level
  ${YELLOW}git-tutor sandbox${NC}               Start sandbox mode

${GREEN}Levels:${NC}
  ${YELLOW}level_1${NC}                         Basic commits and branch creation

${GREEN}Git Commands:${NC}
  ${YELLOW}commit [--amend]${NC}                Create a new commit
  ${YELLOW}checkout [-b] <ref>${NC}             Checkout or create a branch
  ${YELLOW}switch [-c] <ref>${NC}               Switch or create a branch
  ${YELLOW}cherry-pick <commit>${NC}            Cherry-pick a commit to current branch
  ${YELLOW}rebase <branch>${NC}                 Rebase current branch onto specified branch
  ${YELLOW}branch <name>${NC}                   Create a new branch
  ${YELLOW}merge <name>${NC}                    Merge Branches
  ${YELLOW}log [--all]${NC}                     Show commit history
  ${YELLOW}revert <commit>${NC}                 Revert a commit
  ${YELLOW}reset <ref>${NC}                     Reset HEAD to specified commit

${GREEN}Tool Commands:${NC}
  ${YELLOW}Description${NC}                     Shows Level Description
  ${YELLOW}Hint${NC}                            Show Hint on How to solve the Level
  ${YELLOW}clear${NC}                           Clear screen and show progress
  ${YELLOW}reset${NC}                           Reset current level
  ${YELLOW}help${NC}                            Show this help message
  ${YELLOW}exit${NC}                            Exit the game
"
}

main() {

    local mode=$1
    if [[ "$#" -eq 0 ]]; then
        show_help
        exit 0
    elif [[ "$mode" == 'sandbox' && "$#" -eq 1 ]]; then
        cmd_exe_sandbox
    elif [[ "$mode" == 'play' ]]; then
        if [[ "$#" -eq 2 ]]; then
            local level_name=$2
            level_setup "$level_name"
            cmd_exe_play "$level_name"
        else
            show_help
            exit 1
        fi
    else
        show_help
        exit 1
    fi
}

main "$@"
